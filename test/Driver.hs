{-# OPTIONS_GHC -F -pgmF tasty-discover -optF --in-place #-}
-- GENERATED BY tasty-discover
{-# LANGUAGE FlexibleInstances #-}

module Main (main, ingredients, tests) where

import Data.String (fromString)
import Prelude
import qualified BackupFiles.ValidTest
import qualified ConfigTest
import qualified DiscoverTest
import qualified ModulesGlob.Sub.OneTest
import qualified ModulesGlob.TwoTest
import qualified SubMod.FooBaz
import qualified SubMod.PropTest
import qualified SubMod.SubSubMod.PropTest
import qualified System.Environment as E
import qualified Test.Tasty as T
import qualified Test.Tasty.Discover as TD
import qualified Test.Tasty.HUnit as HU
import qualified Test.Tasty.Hedgehog as H
import qualified Test.Tasty.Hspec as HS
import qualified Test.Tasty.Ingredients as T
import qualified Test.Tasty.QuickCheck as QC
import qualified Test.Tasty.SmallCheck as SC

{- HLINT ignore "Evaluate" -}
{- HLINT ignore "Use let" -}






class TestGroup a where testGroup :: String -> a -> IO T.TestTree
instance TestGroup T.TestTree        where testGroup _ a = pure a
instance TestGroup [T.TestTree]      where testGroup n a = pure $ T.testGroup n a
instance TestGroup (IO T.TestTree)   where testGroup _ a = a
instance TestGroup (IO [T.TestTree]) where testGroup n a = T.testGroup n <$> a

class TestCase a where testCase :: String -> a -> IO T.TestTree
instance TestCase (IO ())                      where testCase n = pure . HU.testCase      n
instance TestCase (IO String)                  where testCase n = pure . HU.testCaseInfo  n
instance TestCase ((String -> IO ()) -> IO ()) where testCase n = pure . HU.testCaseSteps n

tests :: IO T.TestTree
tests = do
  t0 <- pure $ QC.testProperty "validTest" BackupFiles.ValidTest.prop_validTest

  t1 <- HS.testSpec "modules" ConfigTest.spec_modules

  t2 <- HS.testSpec "ignores" ConfigTest.spec_ignores

  t3 <- HS.testSpec "badModuleGlob" ConfigTest.spec_badModuleGlob

  t4 <- HS.testSpec "backupFilesIgnored" ConfigTest.spec_backupFilesIgnored

  t5 <- HS.testSpec "modulesGlobIgnoresDirectories" ConfigTest.spec_modulesGlobIgnoresDirectories

  t6 <- HS.testSpec "customModuleName" ConfigTest.spec_customModuleName

  t7 <- testCase "noTreeDisplayDefault" ConfigTest.unit_noTreeDisplayDefault

  t8 <- testCase "treeDisplay" ConfigTest.unit_treeDisplay

  t9 <- pure $ QC.testProperty "mkModuleTree" ConfigTest.prop_mkModuleTree

  t10 <- HS.testSpec "commentHandling" ConfigTest.spec_commentHandling

  t11 <- HS.testSpec "symlinksNotFollowed" ConfigTest.spec_symlinksNotFollowed

  t12 <- TD.tasty (TD.description "symlinksNotFollowed" <> TD.name "ConfigTest.tasty_symlinksNotFollowed") ConfigTest.tasty_symlinksNotFollowed

  t13 <- testCase "listCompare" DiscoverTest.unit_listCompare

  t14 <- pure $ QC.testProperty "additionCommutative" DiscoverTest.prop_additionCommutative

  t15 <- pure $ SC.testProperty "sortReverse" DiscoverTest.scprop_sortReverse

  t16 <- HS.testSpec "prelude" DiscoverTest.spec_prelude

  t17 <- testGroup "addition" DiscoverTest.test_addition

  t18 <- testGroup "multiplication" DiscoverTest.test_multiplication

  t19 <- testGroup "generateTree" DiscoverTest.test_generateTree

  t20 <- testGroup "generateTrees" DiscoverTest.test_generateTrees

  t21 <- TD.tasty (TD.description "reverse" <> TD.name "DiscoverTest.tasty_reverse") DiscoverTest.tasty_reverse

  t22 <- TD.tasty (TD.description "skip me" <> TD.name "DiscoverTest.tasty_skip_me") DiscoverTest.tasty_skip_me

  t23 <- pure $ H.testPropertyNamed "reverse" (fromString "DiscoverTest.hprop_reverse") DiscoverTest.hprop_reverse

  t24 <- pure $ QC.testProperty "subTest" ModulesGlob.Sub.OneTest.prop_subTest

  t25 <- pure $ QC.testProperty "topLevelTest" ModulesGlob.TwoTest.prop_topLevelTest

  t26 <- pure $ QC.testProperty "additionCommutative" SubMod.FooBaz.prop_additionCommutative

  t27 <- pure $ QC.testProperty "multiplationDistributiveOverAddition" SubMod.FooBaz.prop_multiplationDistributiveOverAddition

  t28 <- pure $ QC.testProperty "additionAssociative" SubMod.PropTest.prop_additionAssociative

  t29 <- pure $ QC.testProperty "additionCommutative" SubMod.SubSubMod.PropTest.prop_additionCommutative

  pure $ T.testGroup "test/Driver.hs" [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,t17,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27,t28,t29]
ingredients :: [T.Ingredient]
ingredients = T.defaultIngredients
main :: IO ()
main = do
  args <- E.getArgs
  E.withArgs ([] ++ args) $    tests >>= T.defaultMainWithIngredients ingredients

