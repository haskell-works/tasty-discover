{-# OPTIONS_GHC -F -pgmF tasty-discover -optF --in-place #-}
-- GENERATED BY tasty-discover
{-# LANGUAGE FlexibleInstances #-}

{-# OPTIONS_GHC -Wno-orphans #-}

module Main (main, ingredients, tests) where

import Prelude
import qualified ConfigTest
import qualified DiscoverTest
import qualified SubMod.FooBaz
import qualified SubMod.PropTest
import qualified SubMod.SubSubMod.PropTest
import qualified System.Environment as E
import qualified Test.Tasty as T
import qualified Test.Tasty.Discover as TD
import qualified Test.Tasty.HUnit as HU
import qualified Test.Tasty.Hedgehog as H
import qualified Test.Tasty.Hspec as HS
import qualified Test.Tasty.Ingredients as T
import qualified Test.Tasty.QuickCheck as QC
import qualified Test.Tasty.SmallCheck as SC

{- HLINT ignore "Use let" -}







instance TD.TestCase (IO ())                      where testCase d _ = pure . HU.testCase      d
instance TD.TestCase (IO String)                  where testCase d _ = pure . HU.testCaseInfo  d
instance TD.TestCase ((String -> IO ()) -> IO ()) where testCase d _ = pure . HU.testCaseSteps d

tests :: IO T.TestTree
tests = do
  t0 <- HS.testSpec "modules" ConfigTest.spec_modules

  t1 <- HS.testSpec "ignores" ConfigTest.spec_ignores

  t2 <- HS.testSpec "badModuleGlob" ConfigTest.spec_badModuleGlob

  t3 <- HS.testSpec "customModuleName" ConfigTest.spec_customModuleName

  t4 <- TD.testCase "noTreeDisplayDefault" "noTreeDisplayDefault" ConfigTest.unit_noTreeDisplayDefault

  t5 <- TD.testCase "treeDisplay" "treeDisplay" ConfigTest.unit_treeDisplay

  t6 <- pure $ QC.testProperty "mkModuleTree" ConfigTest.prop_mkModuleTree

  t7 <- TD.testCase "listCompare" "listCompare" DiscoverTest.unit_listCompare

  t8 <- pure $ QC.testProperty "additionCommutative" DiscoverTest.prop_additionCommutative

  t9 <- pure $ SC.testProperty "sortReverse" DiscoverTest.scprop_sortReverse

  t10 <- HS.testSpec "prelude" DiscoverTest.spec_prelude

  t11 <- TD.testGroup "addition" "DiscoverTest.test_addition" DiscoverTest.test_addition

  t12 <- TD.testGroup "multiplication" "DiscoverTest.test_multiplication" DiscoverTest.test_multiplication

  t13 <- TD.testGroup "generateTree" "DiscoverTest.test_generateTree" DiscoverTest.test_generateTree

  t14 <- TD.testGroup "generateTrees" "DiscoverTest.test_generateTrees" DiscoverTest.test_generateTrees

  t15 <- pure $ H.testProperty "reverse" DiscoverTest.hprop_reverse

  t16 <- TD.testGroup "goldenTest" "DiscoverTest.custom_goldenTest" DiscoverTest.custom_goldenTest

  t17 <- pure $ QC.testProperty "additionCommutative" SubMod.FooBaz.prop_additionCommutative

  t18 <- pure $ QC.testProperty "multiplationDistributiveOverAddition" SubMod.FooBaz.prop_multiplationDistributiveOverAddition

  t19 <- pure $ QC.testProperty "additionAssociative" SubMod.PropTest.prop_additionAssociative

  t20 <- pure $ QC.testProperty "additionCommutative" SubMod.SubSubMod.PropTest.prop_additionCommutative

  pure $ T.testGroup "test/Driver.hs" [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,t17,t18,t19,t20]
ingredients :: [T.Ingredient]
ingredients = T.defaultIngredients
main :: IO ()
main = do
  args <- E.getArgs
  E.withArgs ([] ++ args) $    tests >>= T.defaultMainWithIngredients ingredients

